---
icon: article
date: 2022-01-10
title: Go 进阶1
category:
- 后端
- Go

tag:
- Go 进阶1
---

## 知识

### 各语言区别

![image-20220927152606790](./项目笔记\image-20220927152606790.png)



### runtime

![image-20220927153206014](./项目笔记\image-20220927153206014.png)



### Go编译过程

![image-20220927153713717](./项目笔记\image-20220927153713717.png)



### 查看中间码生成

![image-20220927154011718](./项目笔记\image-20220927154011718.png)



### 查看机器码

![image-20220927154347804](./项目笔记\image-20220927154347804.png)



### 空结构体

长度为0，并且都指向同一个地址（runtime.malloc.zero），主要为了节约内存



### 字符串

由于字符串底层实际是结构体，因此unsafe.Sizeof()任何字符串长度都为16

```
// 实际操作是结构体
type stringStruct struct {
	str unsafe.Pointer
	len int
}
```

```
// reflect/value.go下有类似结构体
type StringHeader struct {
	Data uintptr
	Len  int
}
```



### Unicode

![image-20220928101436832](./项目笔记\image-20220928101436832.png)



### UTF-8

![image-20220928101515519](./项目笔记\image-20220928101515519.png)



### 切片

![image-20220929094647712](./image-20220929094647712.png)



### Map

#### HashMap

##### 开放寻址法

![image-20220929095212521](./image-20220929095212521.png)



##### 拉链法

![image-20220929095202581](./image-20220929095202581.png)



#### map

##### 结构原理

![image-20220929095459550](./image-20220929095459550.png)

![image-20220929101620041](./image-20220929101620041.png)

![image-20220929101504543](./image-20220929101504543.png)





##### 字面量操作

![image-20220929101426693](./image-20220929101426693.png)

![image-20220929101356777](./image-20220929101356777.png)



##### 溢出扩容

![image-20220929102704826](./image-20220929102704826.png)



步骤

1. 创建新的桶（可能扩容），把旧的桶挂载到oldbuckets
2. 采用渐进式迁移数据

![image-20220929103556083](./image-20220929103556083.png)



当对旧桶操作时（如更新数据），会在操作完后还要负责桶的迁移。

如下图，旧桶B=2，新桶B=3, 当某键通过hasher得到哈希值时，由于新桶B=3,取该哈希值的后三位，此时后三位数字有两种可能，要么110，要么010，则定位的新桶桶号会有两个，3和6号桶，然后迁移旧桶数据到对应新桶。可以看出将旧桶的数据一分为二放置到新桶上，解决了溢出桶问题

![image-20220929103607893](./image-20220929103607893.png)

![image-20220929103732870](./image-20220929103732870.png)

3. 当发现旧桶所有数据迁移完后，便回收旧桶空间



#### sync.Map

由于map不允许并发（加锁控制并发会影响读写性能），于是go开发了sync.Map来支持并发的map

![image-20220929155912229](./image-20220929155912229.png)

![image-20220929160435250](./image-20220929160435250.png)



![image-20220929160404926](./image-20220929160404926.png)



追加后读写，先走m, 发现amended = true,走dirty,读到值后，misses加1。知道misses等于dirty长度的时候，就忍不了了，因为经常走dirty流程比较繁琐。于是m的map指向dirty,dirty的map变为空，同时amended = true，表示m的map已完整，misses归零。当下次要追加操作访问dirty时，dirty重建read的map。

![image-20220929160801461](./image-20220929160801461.png)

![image-20220929162535798](./image-20220929162535798.png)



### interface

![image-20220929163136074](./image-20220929163136074.png)



#### 结构体和指针实现接口区别

用结构体实现的方法，编译时会自动生成该结构体指针实现的方法。

```
type children interface{ grade() }
type student struct {}
func(s student) grade() {}

var c children = &student{} // 不会报错，编译时自动生成该结构体指针的grade方法
```

而用结构体指针实现的方法，编译时不会自动生成结构体实现的方法。

```
type children interface{ grade() }
type student struct {}
func(s *student) grade() {}

var c children = student{} // 会报错，编译没有实现实例结构体的grade方法
```

这是个单向过程。

![image-20220929164100533](./image-20220929164100533.png)



#### 普通接口

```
type iface struct {
	tab  *itab
	data unsafe.Pointer
}
```





#### 空接口

```
type eface struct {
	_type *_type
	data  unsafe.Pointer
}
```

比普通接口更省空间，常用于任意类型作为函数入参



### 协程



![image-20221010181400707](./image-20221010181400707.png)



#### 底层结构

![image-20221010182018573](./image-20221010182018573.png)



![image-20221010182417132](./image-20221010182417132.png)

 

![image-20221010183115266](./image-20221010183115266.png)

![image-20221010184643118](./image-20221010184643118.png)



#### GMP调度模型

![image-20221010184614501](./image-20221010184614501.png)



优先执行新建协程

![image-20221010185316375](./image-20221010185316375.png)



#### 解决饥饿问题

切换线程方案

![image-20221010190407375](./image-20221010190407375.png)



![image-20221010190529657](./image-20221010190529657.png)



每次函数跳转会使用morestack方法来判断协程栈空间是否足够，常用，

故在morestack中加入钩子，判断该协程是否抢占执行（超过10ms即抢占）。

若抢占则直接跳转到schedule

![image-20221011091535260](./image-20221011091535260.png)



若一直没有函数跳转，则会使用线程信号，线程信号会让线程紧急跳转到某个函数。

先注册SIGURG信号的处理函数，当GC工作时，基本线程业务都停止了，

然后GC向目标线程发送信号。线程收到信号，触发调度

![image-20221011092321969](./image-20221011092321969.png)



#### 协程过多问题

利用channel的缓冲区，来控制协程运行的数量。 当channel满后，会卡住，无法创建新的协程。



### 锁



#### 问题检测

锁拷贝有可能导致死锁问题

```
go vet main.go // 查看有无复制锁
```

查看是否有数据竞争问题

```
go build -race main.go 
.\main.exe
```

死锁检测go-deadlock

![image-20221013102443315](./image-20221013102443315.png)



#### atomic

atomic包底层加了硬件级别的锁



#### sema锁

信号锁，经常用作休眠协程队列

![image-20221013110245975](./image-20221013110245975.png)

![image-20221013110218853](./image-20221013110218853.png)





#### mutex锁

![image-20221011160447559](./image-20221011160447559.png)



![image-20221011160527135](./image-20221011160527135.png)





![image-20221011160422650](./image-20221011160422650.png)

![image-20221011163513324](./image-20221011163513324.png)



#### rwmutex锁

有写锁，读写都不行；有读锁，可以继续读，但不能写	

![image-20221012153649479](./image-20221012153649479.png)



![image-20221012154038034](./image-20221012154038034.png)

![image-20221012154805011](./image-20221012154805011.png)

![image-20221013081740765](./image-20221013081740765.png)



#### waitgroup锁

原理：

wg.Wait()会留意waiter,若waiter为0，则返回，否则waiter+1且休眠等待，线程会卡住。

wg.Add()和wg.Done()控制counter数量。若counter为0，表示协程任务完成了，则唤醒所有wg.Wait()的线程



waiter：正在等待的协程

counter：被等待的，待完成的协程

sema：协程队列



![image-20221013082519202](./image-20221013082519202.png)



![image-20221013082802614](./image-20221013082802614.png)



![image-20221013083004114](./image-20221013083004114.png)



#### Once锁



![image-20221013083929612](./image-20221013083929612.png)



### 管道

![image-20221013105839121](./image-20221013105839121.png)



#### 底层结构

![image-20221013135242354](./image-20221013135242354.png)

![image-20221013135507082](./image-20221013135507082.png)

![image-20221013135808180](./image-20221013135808180.png)



#### 发送数据

有等待的接收者，直接发给接收者，然后唤醒该接收者

![image-20221013140553559](./image-20221013140553559.png)



无等待的接收者，将数据放入缓冲区

![image-20221013140816647](./image-20221013140816647.png)



无等待的接收者，且缓冲区已满。将自己包装成sudog，放入等待发送者队列，休眠。

直到有接收者从缓冲区获取数据，使缓冲区有空闲，再把该发送者数据放入缓冲区后，才唤醒该发送者

![image-20221013140931286](./image-20221013140931286.png)



![image-20221013141149553](./image-20221013141149553.png)



#### 接收数据

![image-20221013170121341](./image-20221013170121341.png)



无缓存，无等待的发送者，自己包装成sudug，休眠。

![image-20221013171015319](./image-20221013171015319.png)



无缓冲，有等待的发送者，直接获取数据，唤醒该发送者

![image-20221013170239054](./image-20221013170239054.png)



有缓存数据，直接从缓存中获取数据。

![image-20221013170951013](./image-20221013170951013.png)



有缓存，且有等待的发送者。从缓存获取数据，将发送者的数据放入缓存中，然后唤醒该发送者。

![image-20221013171156484](./image-20221013171156484.png)



### TCP

![image-20221017162627317](./image-20221017162627317.png)



#### io模型

##### 堵塞io

![image-20221017161950235](./image-20221017161950235.png)



![image-20221017162509249](./image-20221017162509249.png)

![image-20221017162709487](./image-20221017162709487.png)



##### 非堵塞io

![image-20221017162720213](./image-20221017162720213.png)

![image-20221017162923687](./image-20221017162923687.png)



##### 多路复用

![image-20221017163213455](./image-20221017163213455.png)

![image-20221017163227399](./image-20221017163227399.png)

![image-20221017185647340](./image-20221017185647340.png)



#### netpoll

![image-20221017190040539](./image-20221017190040539.png)



##### netpollinit

![image-20221017190326423](./image-20221017190326423.png)



##### netpollopen

![image-20221017190724956](./image-20221017190724956.png)



##### netpoll

![image-20221017191100560](./image-20221017191100560.png)



##### 初始化

![image-20221017191424862](./image-20221017191424862.png)



![image-20221017192230675](./image-20221017192230675.png)



##### 新增

![image-20221017192203649](./image-20221017192203649.png)



##### 收发数据

![image-20221017192413379](./image-20221017192413379.png)



![image-20221017193725237](./image-20221017193725237.png)



![image-20221017194350464](./image-20221017194350464.png)

![image-20221017194635870](./image-20221017194635870.png)



#### net包



![image-20221019094947712](./image-20221019094947712.png)



![image-20221019095727664](./image-20221019095727664.png)



![image-20221019102924228](./image-20221019102924228.png)



#### 总模型

![image-20221020081234611](./image-20221020081234611.png)



### 内存管理

go的栈是在堆上分配的

栈记录了运行记录，本地变量，函数参数，函数指令



#### 协程栈太小怎么办

##### 逃逸分析

将变量从栈上放置到堆上，分别有指针逃逸，空接口逃逸，大变量逃逸

![image-20221020083630478](./image-20221020083630478.png)



![image-20221020083643148](./image-20221020083643148.png)



#### 扩容栈空间

![image-20221020084104733](./image-20221020084104733.png)



### 堆内存



![image-20221020084445915](./image-20221020084445915.png)



![image-20221020084714678](./image-20221020084714678.png)

![image-20221020102522461](./image-20221020102522461.png)



![image-20221020104734007](./image-20221020104734007.png)



### 垃圾回收

#### 回收方案

直接清除，内存碎片化严重

但由于go的堆结构是以64MB为单位，不用担心碎片化，故采用此方案

![image-20221020091021985](./image-20221020091021985.png)



每次清除后需要整理，开销大

![image-20221020091040750](./image-20221020091040750.png)



要开辟一片大空间，内存开销大

![image-20221020091051422](./image-20221020091051422.png)



#### GC原理

![image-20221020091453830](./image-20221020091453830.png)



![image-20221020091803437](./image-20221020091803437.png)



##### 串行GC

对性能影响大

![image-20221020091905094](./image-20221020091905094.png)



#### 并发垃圾回收

##### 三色标记法

![image-20221020092154738](./image-20221020092154738.png)



##### 删除屏障

并发时，某指针要释放了，其对应的白色对象要置灰，避免误删

![image-20221020094653329](./image-20221020094653329.png)



##### 插入屏障

若对象一开始就没指针引用，而后面才被黑色标记的对象引用。会因此不能将该对象加入灰色队列，最终也没有分析标记该对象，因此被误删。

而插入屏障会将指针指向的白色对象置灰。而因为该对象加入了灰色队列，因此最终会被分析标记到。

![image-20221020095923382](./image-20221020095923382.png)



##### 混合屏障

![image-20221020100928373](./image-20221020100928373.png)



#### GC触发

![image-20221020101216287](./image-20221020101216287.png)



![image-20221020101414429](./image-20221020101414429.png)



mallocgc时会伴随GC

![image-20221020101519707](./image-20221020101519707.png)



#### GC优化

![image-20221020101657647](./image-20221020101657647.png)



![image-20221020101846981](./image-20221020101846981.png)



### cgo



![image-20221020142114577](./image-20221020142114577.png)



![image-20221020142151016](./image-20221020142151016.png)



![image-20221020142219701](./image-20221020142219701.png)



![image-20221020142346116](./image-20221020142346116.png)



### defer

![image-20221020142930308](./image-20221020142930308.png)



![image-20221020143039031](./image-20221020143039031.png)



![image-20221020143156106](./image-20221020143156106.png)



### 反射

![image-20221020144751592](./image-20221020144751592.png)



## 功能



```
选中结构体，ctrl+i，选择接口，自动生成对应方法
```