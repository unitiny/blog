---
icon: article
date: 2022-01-10
title: 设计模式
category:
- 后端
- Go
- 其他

tag:
- 设计模式
---

[学习网址](https://juejin.cn/post/7095581880200167432)



## 工厂模式

### 特点

- 工厂，产品都看作对象，先抽象出各自的父级接口，即所有该对象都具备的功能

	```
	// Cache 抽象父类产品接口
	type Cache interface {
		Set(key, value string)
		Get(key string) string
	}
	
	// Factory 抽象父类工厂接口
	type Factory interface {
		Create() Cache
	}
	```

- 然后对每个工厂和每个产品具体实现，从而实现每个对象的特殊性

### 示例

```
func TestFactory(t *testing.T) {
	var Factory Factory
	Factory = new(RedisFactory)

	redis := Factory.Create()
	redis.Set("abc", "123")
	fmt.Println(redis.Get("abc"))

	Factory = new(MemCacheFactory)
	memCache := Factory.Create()
	memCache.Set("efg", "456")
	fmt.Println(memCache.Get("efg"))
}
```

### 总结

每个功能界限明了，对外用户只需暴露接口，使用方便







## 装饰模式

### 特点

- 用一个结构体作总控制器，储存装饰器和核心业务，curMW为使用装饰器的索引

	```
	type Engine struct {
	   curMW int
	   mw    []middleWare
	   HandleFunc
	}
	```

- 使用递归结构，层层调用装饰器，装饰器完成功能后再返回控制器函数，直到调用核心业务函数。

	这阶段属于业务前的装饰器功能。

	```
	func (e *Engine) Controller(w http.ResponseWriter, r *http.Request) error {
		if e.curMW == len(e.mw)-1 {
			defer func() {
				e.curMW = -1
			}()
			return e.HandleFunc(w, r)
		}
	
		e.curMW++
		err := e.mw[e.curMW](w, r)
		if err != nil {
			return err
		}
	
		return nil
	}
	```

- 业务后的功能则使用defer来处理

	```
	func (e *Engine) useTime(w http.ResponseWriter, r *http.Request) error {
		log.Println("useTime start")
		startTime := time.Now()
	
		defer func() {
			log.Println("spend Time ", time.Since(startTime))
		}()
		return e.Controller(w, r)
	}
	```



### 总结

多用于中间件的实现



## 策略模式

### 特点

根据不同的使用场景，使用不同的策略。用户主要使用父类管理



### 示例

- 抽象父类管理器，面向客户使用

	```
	// LoggerManager 父类管理器
	type LoggerManager struct {
		Logging
	}
	
	// Logging 抽象父类使用接口（功能）
	type Logging interface {
		Info()
		Error()
	}
	
	func NewLoggerManager(l Logging) *LoggerManager {
		return &LoggerManager{l}
	}
	```

- 实现具体子类方法，然后父类获取具体方法给客户使用

	```
	// Logger 具体实现子类
	type Logger struct {
	}
	
	func (l *Logger) Info() {
		fmt.Println("logger Info 日志")
	}
	
	func (l *Logger) Error() {
		fmt.Println("logger Error 日志")
	}
	```

- 客户使用只需更换父类中的子类对象

	```
	func TestLoggerManager(t *testing.T) {
		logger := &Logger{}
		loggerManager := NewLoggerManager(logger)
		loggerManager.Info()
		loggerManager.Error()
	
		dba := &DBA{}
		loggerManager.Logging = dba
		loggerManager.Info()
		loggerManager.Error()
	}
	```

	





### 总结

![image-20220919104555343](D:\Typora\Markdown\后端\Go\image-20220919104555343.png)