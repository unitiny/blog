---
icon: article
date: 2022-01-10
title: MySQL 进阶
category:
- 后端
- SQL

tag:
- MySQL 进阶
---

## 知识点

### excel和mysql区别

![image-20220913154716811](./image-20220913154716811.png)

![image-20220913154755606](./image-20220913154755606.png)





### 经典架构

#### 分层架构

如MVC, docker, linux,前后端分离

![image-20220913154826091](./image-20220913154826091.png)



#### 事件驱动架构

消息中间件

![image-20220913154948753](./image-20220913154948753.png)



#### 管道-过滤器架构

流水线结构

![image-20220913155101168](./image-20220913155101168.png)



#### 微核架构

vscode，本身内核小，只满足基本功能，通过安装插件使功能丰富。

![image-20220913155147662](./image-20220913155147662.png)





### MySQL软件架构

有管道-过滤器架构思想和微核架构思想

![image-20220913155345394](./image-20220913155345394.png)



### 存储引擎

#### MyISAM

由于没有事务和log，功能少因此运行速度快，空间利用率高

![image-20220913163640440](./image-20220913163640440.png)





#### InnoDB

![image-20220913163829462](./image-20220913163829462.png)



#### Archive

![image-20220913164002970](./image-20220913164002970.png)

![image-20220913164210103](./image-20220913164210103.png)



### 索引查找方法

![image-20220913193327155](./image-20220913193327155.png)

#### B Tree

对范围查找每次都得从根节点开始

![image-20220913195645716](./image-20220913195645716.png)



#### B+ Tree

范围查找更快速

![image-20220913195947054](./image-20220913195947054.png)



### 聚簇索引

![image-20220913200401487](./image-20220913200401487.png)

![image-20220913200907743](./image-20220913200907743.png)



### 辅助索引

依然是个B+树，不过叶子节点不记录数据，而是记录主键索引

![image-20220913201438678](./image-20220913201438678.png)



### InnoDB

#### 逻辑存储结构

![image-20220913201831023](./image-20220913201831023.png)





![image-20220913202645471](./image-20220913202645471.png)

![image-20220913202609654](./image-20220913202609654.png)



#### 变长列

![image-20220913203230599](./image-20220913203230599.png)

#### 行溢出

![image-20220913203541407](./image-20220913203541407.png)

![image-20220913203743134](./image-20220913203743134.png)



#### 行记录格式

![image-20220915085410348](./image-20220915085410348.png)



变长字段长度表只记载变长列的偏移量，null标志位是用8位的bit记录某列是否为null，比记录在长度表中字符串更省空间。header记录一些需要的信息。数据溢出的列使用指针，数据存储在其他页里

![image-20220915090200922](./image-20220915090200922.png)



### 左侧索引

![image-20220915091024172](./image-20220915091024172.png)

![image-20220915091135523](./image-20220915091135523.png)



### 回表

```
mysql回表指的是在InnoDB的储存引擎下，通过二级索引查找结果后要返回某些列的信息（即要拿到数据），
则需要到主键索引里取出数据。因为二级索引的B+树的叶子节点储存的是主键索引，主键索引的B+树的叶子节点
才储存的是数据
```



### 索引覆盖

查询主键或联合索引的数据列就能索引覆盖，只要查询一次，因为索引B+树的叶子节点中储存了主键和联合索引。而需要非索引的字段数据，则要查询两次，即查到索引后再回表到主键B+树的叶子节点中获取数据，更加耗时。

![image-20220915161037677](./image-20220915161037677.png)



### where优化

#### 确定索引

抽样检测，索引基数会不精确。可以使用force index强制索引，或者用analyze table优化索引

![image-20220915161242961](./image-20220915161242961.png)



### count优化

count(列名) 

需要通过主键索引得到并解析行数据（回忆InnoDB的行记录格式），还需给service层判断是否为空

count(主键) 

因索引覆盖，不用解析行数据，查询效率高，但仍要判断是否为空

count(*)

mysql做了优化，直接返回索引树中数据的个数



![image-20220915165247697](./image-20220915165247697.png)

![image-20220915170230320](./image-20220915170230320.png)



### group by 优化



![image-20220915170748934](./image-20220915170748934.png)



![image-20220915171157330](./image-20220915171157330.png)  



当where和order的索引一致时可以走索引覆盖

![image-20220915171314698](./image-20220915171314698.png)



### order by rand() 优化

![image-20220915172102929](./image-20220915172102929.png)



随机分页查询第一条

![image-20220915173016946](./image-20220915173016946.png)



![image-20220915173058302](./image-20220915173058302.png)



### 索引下推

各个索引若明确等于某个值，则先按第一索引查找，

相同的值再按第二索引查找，还相同再按第三索引查找...

而当第一索引不明确则无法继续沿着第二索引查找，

那么只能在第一索引查找的范围内使用第二索引查找了。即索引下推

![image-20220915192817195](./image-20220915192817195.png)



### 松散索引扫描

跳着扫描，如图第一二行数据，因为表是按索引排序的，当film_id前面是2后面是5，那说明store_id为1的行

肯定没有符合film_id = 3的了，则跳过store_id为1的数据行

![image-20220915193744543](./image-20220915193744543.png)



### 索引丢失

若对索引做函数操作，有可能破坏了索引的递增规则，优化器会放弃这个索引

![image-20220915194711728](./image-20220915194711728.png)

![image-20220915195401528](./image-20220915195401528.png)



### 日志体系

![image-20220916094954309](./image-20220916094954309.png)

#### binlog

![image-20220916095116223](./image-20220916095116223.png)



#### undo log

根据操作的sql储存能还原的sql

![image-20220916095331530](./image-20220916095331530.png)



#### redo log 

![image-20220916095715298](./image-20220916095715298.png)

![image-20220916100110801](./image-20220916100110801.png)



### 数据更新流程

![image-20220916101041407](./image-20220916101041407.png)



#### 数据安全

![image-20220916101941012](./image-20220916101941012.png)



![image-20220916101958540](./image-20220916101958540.png)



![image-20220916102324630](./image-20220916102324630.png)



### 锁

![image-20220916102524154](./image-20220916102524154.png)



#### 元数据锁

![image-20220916102736158](./image-20220916102736158.png)





### 事务

#### 隔离类别

![image-20220916103305088](./image-20220916103305088.png)

A,B客户端同时开启mysql事务情况下,A更新了数据，但未提交事务

- 读未提交

	即使A未提交事务,B也能读到数据更新，隔离性差

- 读提交

	A未提交事务，B不能读到数据更新。A提交事务后，B就能看到数据更新。Oracle使用这一级别隔离

- 可重复读

	不管A操作了什么（即使提交事务），B一直读取的是开启事务前的数据。mysql使用这一级别的隔离

- 串行化

​		对于一行数据，只允许一个事务同时操作，隔离性最强，但性能差



#### 事务问题

![image-20220916154032602](./image-20220916154032602.png)

![image-20220916154504442](./image-20220916154504442.png)



#### 读取历史表

![image-20221017155237565](./image-20221017155237565.png)

根据事务begin开始时间，把数据回退到begin前要版本

![img-11111](./image-20221017155418988.png)





#### mysql解决幻读

![image-20220916154833024](./image-20220916154833024.png)



#### 间隙锁和Next-Key Lock的性能问题

![image-20220916155155396](./image-20220916155155396.png)



先锁（10，20], 但TxA 是等值查询id=11的，键20不满足条件，不加行锁

![image-20220916160647702](./image-20220916160647702.png)



![image-20220916160702011](./image-20220916160702011.png)



![image-20220916160717830](./image-20220916160717830.png)



![image-20220916160737039](./image-20220916160737039.png)



![image-20220916160830012](./image-20220916160830012.png)



### ORM

![image-20220916161453209](./image-20220916161453209.png)



### 备份

#### 分类

![image-20220918145252061](./image-20220918145252061.png)



![image-20220918145441154](./image-20220918145441154.png)



![image-20220918145415012](./image-20220918145415012.png)



#### mysqldump

![image-20220918150625608](./image-20220918150625608.png)



##### 增量备份

![image-20220918151459201](./image-20220918151459201.png)



![image-20220918151613278](./image-20220918151613278.png)



![image-20220918152015858](./image-20220918152015858.png)



![image-20220918152112059](./image-20220918152112059.png)



#### 裸备份可行性

![image-20220918152559925](./image-20220918152559925.png)



在复制期间监听redo.log的变化

![image-20220918153028190](./image-20220918153028190.png)



### 安全防范

![image-20220918154342270](./image-20220918154342270.png)

![image-20220918154417988](./image-20220918154417988.png)



![image-20220918154509430](./image-20220918154509430.png)



![image-20220918154600105](./image-20220918154600105.png)



### 复制

#### 异步复制

![image-20220919094311828](./image-20220919094311828.png)

![image-20220919094110389](./image-20220919094110389.png)



#### 半同步复制

![image-20220919094251275](./image-20220919094251275.png)



主库长时间没收到备库的接收信号，则自动断开

![image-20220919094449056](./image-20220919094449056.png)



#### 组复制

通过共识，多个节点能进行同样的操作

![image-20220919094818216](./image-20220919094818216.png)



![image-20220919094902829](./image-20220919094902829.png)



#### 案例

课程9-3节



#### binlog复制问题

- 若使用statement格式，按sql原句发送到备库，让备库再执行一次sql，可能导致结果不一致。

​        因为主备库的索引id可能不同，而导致排序不一致，得到结果因此不同。

- 使用row格式，则记录的是行数据的变化，然后重构出sql语句让备库执行。



### 备库延迟问题

根本原因还是主库dump_thead是多线程，同时有很多人操作。而备库的sql_thead为单线程，导致延迟

![image-20220920154308489](./image-20220920154308489.png)

![image-20220920154601071](./image-20220920154601071.png)



#### 并行复制

为sql_thead的操作分配线程，需要对sql操作分类复制才能够安全运行。

有按表复制，按行复制，按事务组复制

![image-20220920160338876](./image-20220920160338876.png)



5.6采用按库并行复制

![image-20220920155424718](./image-20220920155424718.png)



#### 按事务组复制

binlog写入顺序，先写进binlog cache缓存中，再写入内存中的binlog file，最后再写入磁盘的binlog file。

写入磁盘中的io操作较慢，每个事务都执行写入磁盘操作性能就比较慢。故可以延迟一会，等待多个事务都写入内存的binlog file后，再一齐写入磁盘。省下写入磁盘操作次数。

![image-20220920155855406](./image-20220920155855406.png)

是在主库中按事务组来提交给备库，备库才能安全的并行执行





### 高可用架构

问题：

数据冲突：若两个主库都有读写权限，数据更新时就会有冲突。得有一方主库为只读权限

客户端切换：某个主库挂了，客户端如何检测并切换到另一个主库上

循环复制：A执行产生的binlog传给B，B执行产生的binlog又传回给A，会一直循环复制。若有GTID，通过binlog的serverID来辨别该binlog来源是谁，从而避免过多复制。

![image-20220920162731385](./image-20220920162731385.png)



### 扩展

#### 分区表

InnoDB将表分成多表，server层仍看作一个表

![image-20220920184535330](./image-20220920184535330.png)

![image-20220920185003371](./image-20220920185003371.png)

![image-20220920185023324](./image-20220920185023324.png)



### 分库分表中间件

dble ，MyCat

#### 原理

![image-20220920190138279](./image-20220920190138279.png)



#### dble

![image-20220920190623243](./image-20220920190623243.png)

![image-20220920191217798](./image-20220920191217798.png)



##### 高可靠架构

为每个分库作个备库（复制 ）



##### 分库后sql性能注意

- 插入语句必须带有拆分字段，就不必遍历所有分库了
- 拆分字段尽量等值
- ![image-20220922092425354](./image-20220922092425354.png)
- ![image-20220922092450776](./image-20220922092450776.png)

- ![image-20220922092619978](./image-20220922092619978.png)




### 切换

#### 业务如何连接到备库

- 客户端切换连接地址
- 多开个服务器，把DNS域名映射的ip替换
- 使用keepalived监听，vip漂移
- 使用代理

![image-20220922134825279](./image-20220922134825279.png)



![image-20220922134859366](./image-20220922134859366.png)



![image-20220922135020072](./image-20220922135020072.png)



![image-20220922135104975](./image-20220922135104975.png)



![image-20220922135209835](./image-20220922135209835.png)



#### 自主切换 MHA

1. 从宕机的Master登陆数据库将未发送的binlog发给备库
2. 等待备库执行中继日志，使备库恢复到主库水平
3. 挑选备库切换为主库（一次性）

![image-20220922140052080](./image-20220922140052080.png)



### 三高MySQL集群

Zookeeper存dble的配置，使单点dble实现分布式，每个dble都拉取得到相同配置，便可使用

Haproxy负载均衡器，将流量负载均衡到各个dble节点

主库开读写权限，备库开只读权限

![](./image-20220922144405327.png)



### MySQL8.0

#### 窗口函数

相当于 group by ，可以对内容排序之类，然后展开里边内容

![image-20220922153937033](./image-20220922153937033.png)



#### 隐藏索引

![image-20220922154128592](./image-20220922154128592.png)



#### 降序索引

![image-20220922154418110](./image-20220922154418110.png)



#### 临时表

![image-20220922154613620](./image-20220922154613620.png)



### 数据库分类

#### 按用途分类

![image-20220922155522694](./image-20220922155522694.png)

![image-20220922155657065](./image-20220922155657065.png)



#### 按存储形式分类

行存，列存，key-value



### PostgreSQL

![image-20220922165900083](./image-20220922165900083.png)



### MySQL改造

![image-20220922170525882](./image-20220922170525882.png)



### OceanBase







## 功能

### 优化设计

![image-20220915101546709](./image-20220915101546709.png)



![image-20220915101657248](./image-20220915101657248.png)

![image-20220915101754709](./image-20220915101754709.png)



## 思考

### 为何mysql不使用查询缓存

说明：每次执行查询语句便将结果缓存，下次执行相同查询时不必重复查询

目的：节省时间，提高性能

缺点：缓存数据大，若数据发生更改，则与该表相关的所有缓存都失效，得全部清空。

​			在高并发的表中反而cpu消耗更多，发挥空间小

![image-20220913162444897](D:\Typora\Markdown\后端\SQL\image-20220913162444897.png)