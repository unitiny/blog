---
icon: article
date: 2022-01-10
title: 数据库系统原理
category:
- 计科

tag:
- 数据库系统原理
---

## 学习

[网址](https://www.bilibili.com/video/BV1ra4y1t7xY?p=7&spm_id_from=pageDriver&vd_source=3ec975651088fba288a277c53f0bcc77)

XMind有整理图谱



## 知识点

### 主码和主属性

主码必须是唯一标识，可不只是用一个属性来充当，为满足唯一需求，可以两个属性组合作为主码
主码中的各属性称为主属性



### 数据模型三要素

数据结构，数据操作，完整性约束



### 实体完整性和参照完整性

实例中的主码必须符合主码的取值约束，即满足实体完整性

实例中的外码必须符合外码的取值约束，即满足参照完整性



### 类型

CHAR 固定长度字符串，尾部空格不会去掉，即使未满也会占用

VARCHAR 可变长度字符串，尾部空格会去掉，有剩余空间会留给其他变量使用

decimal 精确的数据类型



### 约束

PRIMARY KEY 主键

UNIQUE 唯一值，不能重复

![image-20220905192912643](./image-20220905192912643.png)



![image-20220830191758416](./image-20220830191758416.png)





### 关系代数

![image-20220831101443754](./image-20220831101443754.png)

![image-20220831101527411](./image-20220831101527411.png)

![image-20220831103745757](./image-20220831103745757.png)



### SQL

![image-20220905192726956](./image-20220905192726956.png)



### 创建表

![image-20220831212033487](./image-20220831212033487.png)



### 更改表

![image-20220905193140323](./image-20220905193140323.png)



### 单表查询

#### SELECT

select语句先从from开始执行，最后才是select 列名 

year(getdate())  获取当前时间的年份	

distinct 去除重复元组

![image-20220901095246653](./image-20220901095246653.png)



\ 转义字符

![image-20220901100521759](./image-20220901100521759.png)



![image-20220901100639764](./image-20220901100639764.png)



先Sdept升序排，Sdept相等则按Sage降序排

![image-20220901100849468](./image-20220901100849468.png)



#### GROUP BY

![image-20220901140112768](./image-20220901140112768.png)



#### HAVING

是在分组后的结果再筛选

![image-20220901140026232](./image-20220901140026232.png)





### 连接查询

#### 等值连接

![image-20220901142840928](./image-20220901142840928.png)



#### 自身连接

![image-20220901143447716](./image-20220901143447716.png)



#### 内连接

![image-20220905162845451](./image-20220905162845451.png)





#### 外连接

![image-20220905163105724](./image-20220905163105724.png)



##### 左连接

返回select中左表的全部数据，包含两表等值连接的结果和剩余左表未匹配的结果

![image-20220905162921093](./image-20220905162921093.png)



![image-20220905163533433](./image-20220905163533433.png)



### 嵌套查询

select中嵌套子查询select

![image-20220902151247836](./image-20220902151247836.png)

![image-20220902151517111](./image-20220902151517111.png)

![image-20220902153518154](./image-20220902153518154.png)

![image-20220902153536442](./image-20220902153536442.png)





### 删除

#### delete 和 truncate区别

```
delete from sc;
truncate table sc;
功能都是清空表的数据，但是清空的方式不同。

delete是一行一行数据删除
truncate实际执行两个命令，drop table sc; create table sc();
先删除表，再创建空表。当数据量大时，truncate的速度较快
```





### 视图

![image-20220903091012634](./image-20220903091012634.png)

![image-20220903091119027](./image-20220903091119027.png)



创建视图 ，创建时并不执行select，只有查询时才使用

![image-20220903091229086](./image-20220903091229086.png)



### E-R图

#### 如何设计数据库

```
1 列需求选名词，即将独立的对象抽离出来
2 再列出对象里面的属性
3 如果对象属性还可以拆分的话，可以抽离出新的对象，并建立关系
```



![image-20220904154326627](./image-20220904154326627.png)

![image-20220904154630598](./image-20220904154630598.png)



#### 转换关系模式

![image-20220904161926021](./image-20220904161926021.png)





### UML



![image-20220904164534781](./image-20220904164534781.png)



### 规范化理论

对表的合理设计进行衡量，理清冗余数据和不合理的数据依赖

#### 函数依赖

![image-20220904191117081](./image-20220904191117081.png)



![image-20220904191544575](./image-20220904191544575.png)

![image-20220904191634491](./image-20220904191634491.png)

![image-20220904191844927](./image-20220904191844927.png)



#### 范式

```
第一范式 所有属性都是不可分的基本数据项
第二范式 不存在非主属性中有部分函数依赖
第三范式 不存在非主属性中有传递函数依赖
```





![image-20220904193409563](./image-20220904193409563.png)

![image-20220905194221225](./image-20220905194221225.png)

![image-20220904193637589](./image-20220904193637589.png)



#### 坏的关系模式

依赖过多，说了太多的事情



![image-20220904193613590](./image-20220904193613590.png)

![image-20220904193657100](./image-20220904193657100.png)



还得把传递函数依赖分解

![image-20220904194101342](./image-20220904194101342.png)





### 安全控制

#### 权限

![image-20220905093337326](./image-20220905093337326.png)



![image-20220905094326786](./image-20220905094326786.png)

![image-20220905095939749](./image-20220905095939749.png)



同时把U5授权给其他用户的权限也收回

![image-20220905100059007](./image-20220905100059007.png)





### 并发控制

![image-20220905101234745](./image-20220905101234745.png)



#### 事务

![image-20220905101654767](./image-20220905101654767.png)



```
事务交叉并发可能产生的问题
数据不一致（有读写的操作同时执行，导致读取数据出错）
幻行（插入，删除操作同时有读取的事务在执行，导致结果行数缺少或增多）
读脏数据（A事务更新数据，B事务而后读取，然后A事务ROLLBACK回滚，导致B读取出错）
```



#### 锁

![image-20220905110612206](./image-20220905110612206.png)

![image-20220905111307694](./image-20220905111307694.png)



![image-20220905111245591](./image-20220905111245591.png)

![image-20220905111542799](./image-20220905111542799.png)



```
两段锁协议，即加锁就连续加锁知道解锁操作，解锁后面就全部解锁，不能再加锁
```



#### 活锁

加锁时一直等待，申请不到加锁机会，可通过先来先调度解决

![image-20220905112032713](./image-20220905112032713.png)





#### 死锁

![image-20220905112000798](./image-20220905112000798.png)



普通方案解决

![image-20220905112307805](./image-20220905112307805.png)

![image-20220905112325189](./image-20220905112325189.png)



符合DB的解决方案

![image-20220905112508290](./image-20220905112508290.png)



![image-20220905112448491](./image-20220905112448491.png)



### 错误恢复

```
通过转储和重新运行故障前的事务来恢复
```

![image-20220905144251342](./image-20220905144251342.png)

![image-20220905144316169](./image-20220905144316169.png)

![image-20220905144510784](./image-20220905144510784.png)



### 数据库复制



![image-20220905145525632](./image-20220905145525632.png)



### 完整性控制

![image-20220905153139484](./image-20220905153139484.png)



参照关系操作

![image-20220905154635897](./image-20220905154635897.png)



表级完整性

![image-20220905160115543](./image-20220905160115543.png)



列级完整性

![image-20220905160137503](./image-20220905160137503.png)



列约束

![image-20220905160932480](./image-20220905160932480.png)





#### 参照完整性

![image-20220905160336335](./image-20220905160336335.png)





### ACID



![image-20220915095320558](./image-20220915095320558.png)